1. Spring Batch Introduction 1.1. Background  OSSプロジェクトがSOAやmessaging-basedアーキテクチャに注目する一方で，  Javaベースの再利用可能なフレームワークへの注目はかけていた  その結果，その場限りのモノが増殖していった   →要はお前らJavaの使い方間違ってる    SpringSource と Accenture が協力して改善に努めた  Accenture は10年以上前からバッチのフレームワーク構造の構築を続けてきた。  （例：COBOL, C++など）  Spring Batchもその構造に則って作ったゾイ    SpringSource と Accentureは  ず～っと再利用できる，スタンダードとなれるフレームワーク，ツール作りに励んできたよ    1.2. Usage Scenarios  典型的なバッチ処理とは，大量のデータをDBやファイル，キューから読込んで  フォーマットを買え，書き込むものである    Spring Batchはそういった基本的な繰り返し処理を自動で行える  オープンソース唯一のフレームワークである     業務シナリオ    ・周期的なバッチ処理のコミット    ・ジョブの同期／非同期処理    ・Staged（企業のメッセージ駆動処理）    ・大量の並列処理    ・異常終了後のジョブ再開（手動 or スケジュール）    ・部分的な処理（レコードのスキップ）    ・バッチ全体のトランザクション   技術的な主題    開発者は業務ロジックの開発に集中するべし    インフラで起きる心配事の切り分けを明らかにするべし（バッチの実行環境とアプリケーション）    どんなプロジェクトでも実装できる，共通でコアなサービスをインターフェースで提供するべし    core exectionインターフェース（常識にとらわれない）による，デフォルトでシンプルな実装を提供するべし    Springフレームワークの作用により，簡単に設定，カスタマイズ，拡張ができるべし    全てのコアサービスはインフラ層に影響を与えず，簡単に取替えや拡張できるべきである    シンプルな開発モデルを提供するべし   1.3. Spring Batch Architecture  ３層構造   Applicaton   Core   Infrastructure      Application    開発者が作った全てのバッチ処理      Core    バッチジョブを制御するためのランタイムクラス（例：JobLaunchere, Job, Stepの実装）      Infrastructure    共通のreaderやwriterやサービス（例：RetryTemplate）      1.4. General Batch Principles and Guidelines  バッチ実装の基本的な原則   バッチ構造はオンライン構造影響を与えるし，その逆もまたしかり   なので，できる限り共通のブロックで構造と環境を設計しましょう     一つのバッチではできる限りシンプルな構造にしましょう    処理するデータは，実際に存在する場所から閉じておこう   つまり，処理中だけ自分のとこにデータを保持しよう    不要なIOを避けるためレビューしましょう（よくある４つの欠陥）   全てのトランザクションのためにデータを読みこんで，キャッシュなどに溜め込んでおく   トランザクションのために，データの再読み込みをしちゃう   不必要なテーブルやインデックスのスキャン   WHERE句にキーを指定しない    ２回もバッチ処理をするな  バッチ処理のために，十分なメモリを割り当てよう  最悪を想定し，データの整合性チェックをしろ  チェックサム（誤り検出）を実装しろ  負荷テストをしろ  バックアップをとれ    1.5. Batch Processing Strategies  バッチアプリの種類   外部システムからのデータ変換   入出力データの妥当性チェック   DBや入力ファイルからデータを抽出し，出力   DBや入力ファイルからデータを抽出し，更新   データの加工・更新   入力ファイルのフォーマットを変換し出力    よくある有用な処理   Sort   Split   Merge  よくある入力ソース   DB   ファイル   メッセージ  よくある処理オプション   オフラインでの実行（最も簡単）   オンラインでの同期実行   複数の異なるバッチの並列実行   分割（要は同じジョブが同時に多くのインスタンスを処理する）（最も難しい）   ジョブ同士のコンビネーション    ↑をより詳しく書いてあるのが歩けど，またいつか3. The Domain Language of Batch 3.1. Job  バッチ処理そのものであり，Stepのコンテナである   3.1.1. JobInstance   実行したジョブを区別するための概念であり，   ジョブ名とジョブパラメタの組み合わせが同じ場合，同じJobinstanceとなる      JobExecution    ジョブの実行結果や開始，終了時刻といった情報が格納    3.1.2. JobParameters  3.1.3. JobExecution    Job   └JobInstance    └JobExection   3.2. Step  バッチ処理の流れ  3.2.1. StepExecution 3.3. ExecutionContext 3.4. JobRepository 3.5. JobLauncher 3.6. Item Reader 3.7. Item Writer 3.8. Item Processor Item Reader Item WriterJobRepositoryJobLauncherRunning a Job4. Configuring and Running a Job 4.1. Configuring a Job    4.1.1 Restartability    4.1.2 Intercepting Job Execution    4.1.3 Inheriting from a Parent Job  4.1.4 JobParametersValidator   4.2 Java Config  xmlだけでなくJavaでも設定できるよ 4.3 Configuring a JobRepository  JobRepositoryはJobExcectionやStepExectionといったジョブの実効情報が保持される  JobLauncherやJob, Stepが必要となる  基本的に何か実装することはないが，以下のような設定がいる   data-source   transaction-manager   isolation-level-for-create   table-prefix   max-varchar-length （初期値は2500）    4.3.1 Transaction Configuration for the JobRepository   名前空間を使うなら，トランザクション管理は自動的にうまくされる   失敗後のリスタートのためのである，バッチのメタデータが適切に保持されていることを確かめる      isolation-level-for-createのこと   初期値は「SERIALIZABLE」    4.3.2 Changing the Table Prefix   テーブル名の接頭辞を変えれるよ    テスト用にJobRepositoryを作りたい場合などにどうぞ  4.3.3 In-Memory Repository   In Memoryにできるよ    実行速度の向上    単純にデータをのけときたくない 4.4 Configuring a JobLauncher  JobLauncherの基本実装はSimpleJobLauncherだよ   JobRepositryの依存性だけ用意すればいいよ  １度JobExecutionが得られるとJobのexecute()に渡され，最終的にJobEcectionが帰ってくる    HTTPリクエストから起動される場合は気をつけてね   ジョブの開始は非同期である必要があるから，即効でかえしちゃうよ   だってHTTPリクエストを長くもったままにしとくのはよくないからね    TaskExecutorで非同期で処理するジョブの数を制御できるよ 4.5 Running a Job  ジョブを開始するのに最低限必要なものは２つ   ジョブ   JobLauncher      どっちも同じあるいは違うContext内に保管できる    ジョブをコマンドラインから開始したらJVMで各ジョブがインスタンス化される。  そして全てのジョブはJobLauncherを所有する。    ただしHTTPRequestの場合，1つのJobLauncher（非同期開始設定されてる）しかない。      4.5.1 Running Jobs from the Command Line   shellからの起動に着目するね      The CommandLineJobRunner    ApplicationContextのロード    コマンドラインの引数をJobParamatersへと解析    引数を元にジョブの場所を検索    Application Contextで提供されるJobLauncherを使ってジョブの起動        ↑を実現する方法     jobPath ApplicationContextを作るためのxmlファイル     jobName 実行するジョブ名称     ジョブパラメータは"name=value"形式だよ       ExitCodes    ShellにExitCodeを返せるよー    JobExectionはJobLauncheから帰ってくる        ExitCodeMapperを使えば，好きなExitCodeを返せる（String -> number）に変換        初期は SimpleJvmExitCodeMapperだよ     0：成功     1：業務処理内でのエラー     2：業務処理外でのエラー          実装方法はどうやるんだろね？      後でググる    4.5.2 Running Jobs from within a Web Container   HttpRequestからバッチ開始することもよくある（例ad-hoc（その場だけで利用する，特定のための～）, 帳票作成）   気にしなきゃいけないのは，ジョブを非同期に開始しているか確かめること      ControllerがJobLauncherを使ってJob（非同期設定あり）を開始すると，すぐさまJobEcectionを返す。   未だジョブが動いてる可能性があるため，      用は，非同期だから同じの２回以上きたら，それは処理しないようにするため，即効でExitStatusを返して処理を終わらせる。 4.6 Advanced Meta-Data Usage  大規模システムのときはより発展したメタデータへのアクセスが必要だよ    4.6.1 Querying the Repository  余談：query：問いかける   JobRepositoryへ問いかけるためにJobExplorerというのがある      JobExplorerFactoryBeanを使えばよろし    テーブル名の接頭辞を変更してたら，それに合わせた設定をするべし  4.6.2 JobRegistry   必須ではないですしおすし      親context（ここでのcontextはmodule-context（application-context）のことをさす）が   子contextにあるジョブの情報を集めて操作したいときに役に立つ。    登録されているジョブの名前やプロパティを操作できる      JobRegistryBeanPostProcessor    子contextを取り込んで，自分のジョブとして登録できる         AutomaticJobRegistrar    ライフサイクルのコンポーネントのである     子contextを生成したり，子contextのジョブを登録したりするためのコンポーネント          利点は，Jobが複数のmodule-contextを読込んだ際，     同じ名前のReader（例：reader）がいたとき，普通はクラッシュするが     これを回避できる        必須プロパティは２つ     ・ApplicationContextFactories     ・JobLoader        ・ApplicationContextFactories       ApplicationContextFactoryのリスト        ApplicationContextFactory＝子contextの生成クラス         機能の一つとして，デフォルトで親contextの定義を子contextにコピーできる         そのため子contextで再定義する必要がなくなる          ・JobLoader      JobRegistoryに登録された子contextジョブのライフサイクルを管理する                AutomaticJobRegistrar はJobRegistryBeanPostProcessorと接続するときにも役に立つ     もし  4.6.3 JobOperator   JobOperatorは以下をまとめたもの    jobExplorer    jobRepository    jobRegistry    jobLauncher     ※通常はSimpleJobOperatorでよろし     ジョブの停止，再開，ジョブをまとめる     4.6.4 JobParametersIncrementer   JobParamaterが異なる場合，新しいJobInstanceを生成することが目的  4.6.5 Stopping a Job   JobOperatorを使う目的の多くは，ジョブを停止するときである      4.6.6 Aborting a Job   JobRepository は前のプロセスが死んだことを知る由がない    （プロセスそのものが死んだら，JobRepositoryにステータスが書き込まれないから）   手動でステータスをFAILEDかABANDONに変えて，JobRepositoryに教えてあげる必要がある。   そうするとジョブは停止する。    ※Spring Batch Admin のJobServiceのジョブを停止するためのユーティリティがあるよ
